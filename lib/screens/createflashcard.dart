import 'package:flutter/material.dart';
import 'package:speechverse_v2/sqlite/flashcard_db_helper.dart';

// using two databases for scalability and maintanability

// data model for deck

class Deck {
  final int?
      id; // Nullable because the ID is auto-generated by the database upon insertion.
  final String deckName;

  Deck({this.id, required this.deckName});

  // Convert a Deck object into a Map object.
  Map<String, dynamic> toMap() {
    return {
      'id':
          id, // This will be null if it's a new deck that hasn't been inserted into the database yet.
      'deck_name': deckName,
    };
  }

  // Construct a Deck from a Map object.
  factory Deck.fromMap(Map<String, dynamic> map) {
    return Deck(
      id: map['id'],
      deckName: map['deck_name'],
    );
  }
}

class CreateFlashcard extends StatefulWidget {
  const CreateFlashcard({super.key});

  @override
  _CreateFlashcardState createState() => _CreateFlashcardState();
}

class _CreateFlashcardState extends State<CreateFlashcard> {
  List<Deck> _decks = []; // Populated from the database
  Deck? _selectedDeck;

  @override
  void initState() {
    super.initState();
    _loadDecks();
  }

  final _frontTextController = TextEditingController();
  final _backTextController = TextEditingController();

  Future<void> _loadDecks() async {
    final List<Map<String, dynamic>> deckMaps =
        await FlashcardDatabaseHelper.instance.getAllDecks();
    setState(() {
      _decks = deckMaps.map((map) => Deck.fromMap(map)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Flashcard'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            DropdownButton<Deck>(
              iconEnabledColor: Colors.blueAccent,
              iconDisabledColor: Colors.redAccent,
              value: _selectedDeck,
              hint: const Text('Select Deck'),
              onChanged: (Deck? newValue) {
                setState(() {
                  _selectedDeck = newValue;
                });
              },
              // use a drop down here for the decks
              items: _decks.map<DropdownMenuItem<Deck>>((Deck deck) {
                return DropdownMenuItem<Deck>(
                  value: deck,
                  child: Text(deck.deckName),
                );
              }).toList(),
            ),
            const SizedBox(height: 100),
            TextFormField(
              controller: _frontTextController,
              decoration: const InputDecoration(
                labelText: 'Front Text',
              ),
            ),
            const SizedBox(height: 8),
            TextFormField(
              controller: _backTextController,
              decoration: const InputDecoration(
                labelText: 'Back Text',
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _saveFlashcard,
              child: const Text('Save Flashcard'),
            ),
          ],
        ),
      ),
    );
  }

  void _saveFlashcard() async {
    final String frontText = _frontTextController.text;
    final String backText = _backTextController.text;

    // Validate input
    if (frontText.isEmpty || backText.isEmpty || _selectedDeck == null) {
      // remind the user to fill in everything
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
              'Please fill in both sides of the flashcard and select a deck.'),
        ),
      );
      return;
    }

    // save flashcard to the selected deck
    await FlashcardDatabaseHelper.instance.addFlashcard(
      frontText: frontText,
      backText: backText,
      deckId: _selectedDeck!.id!,
    );

    // Clear the text fields
    _frontTextController.clear();
    _backTextController.clear();
    // show confirmation message
    const SnackBar(
      content: Text('Flashcard saved to deck.'),
    );
  }

  @override
  void dispose() {
    _frontTextController.dispose();
    _backTextController.dispose();
    super.dispose();
  }
}
